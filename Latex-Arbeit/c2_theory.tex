\documentclass[bachelor_thesis]{subfiles}

\begin{document}
\chapter{Theoretical Background}
\section{Laser Wakefield Acceleration}
\section{Plasma Wakefield Acceleration}

\section{PIConGPU}
To simulate complex particle-plasma interactions efficiently, the \gls{pic}-Model is often chosen. There are many different code implementations, for this thesis PIConGPU \cite{PIConGPU2013, PICRepo} is used.

\subsection{Particle-in-Cell model} \label{chap:pic}
\todo{how to cite manual?}
\Gls{pic}-code describes the particles in our simulation box as a distribution function $f_s(\vec{x}, \vec{p}, t)$ of time $t$ , position $\vec{x}$ and momentum $\vec{p}$ for every particle species $s$.
This distribution must now satisfy the collisionless Boltzmann equation, also called Vlasov equation\cite{Vlasov1968}, see \autoref{equ:boltz}.

\begin{equation}
	\frac{\mathrm{d}f_s}{\mathrm{d}t}=\frac{\partial f_s}{\partial t} + \frac{\partial \vec{x}}{\partial t} \frac{\partial f_s}{\partial \vec{x}} + \frac{\partial \vec{p}}{\partial t} \frac{\partial f_s}{\partial \vec{p}} = 0
	\label{equ:boltz}
\end{equation}
Using the Nabla-Operator and the derivatives of $\vec{x}$ and $\vec{p}$, we get \autoref{equ:vlasov} with the Lorentz factor $\gamma$ and the Lorentz Force $\vec{F}_L$, see \autoref{equ:lorentz}.

\begin{equation}
	\partial_t f_s + \frac{\vec{p}}{m_s \gamma} \vec{\nabla}_{\vec{x}} f_s + \vec{F}_L \vec{\nabla}_{\vec{p}} f_s = 0
	\label{equ:vlasov}
\end{equation}

\begin{equation}
	\vec{F}_L=q_s\left(\vec{E}+\vec{v}\times\vec{B}\right)
	\label{equ:lorentz}
\end{equation}

To be a self-consistent set of electro-magnetic equations, the Maxwell equations (see \autoref{equ:maxwell} need to be added, which our $\vec{E}$- and $\vec{B}$-fields need to fulfill. Here $\rho_s$ and $\vec{J}_s$ are the charge and current density for a given species $s$.

\begin{equation}
\begin{aligned}
	\vec{\nabla}\cdot\vec{E}  &= \frac{1}{\epsilon_0}\sum_s \rho_s 									\\
	\vec{\nabla}\cdot\vec{B}  &= 0 														\\
	\vec{\nabla}\times\vec{E} &= -\frac{\partial \vec{B}}{\partial t}									\\
	\vec{\nabla}\times\vec{B}&= \mu_0 \left(\sum_s \vec{J}_s + \epsilon_0 \frac{\partial \vec{E}}{\partial t}\right)	
\end{aligned}
\label{equ:maxwell}
\end{equation}

The \gls{pic} model now makes several simplifications, so these dependencies can be implemented.
At first the time needs to be discretized into timesteps with length $\Delta t$ after which out distribution is updated. The equation system above must then be broken down in a system of steps, which will be processed every timestep.
This system is often called the \gls{pic}-cycle \cite{Huebl2019}, which can be seen in \autoref{fig:cycle}.

\begin{figure}
	\centering
	\missingfigure{}
	\caption{The \gls{pic}-cycle. Every timestep starts at .}
	\label{fig:cycle}
\end{figure}\todo{add image and start point}

Then, instead of a distribution function $f_s(\vec{x}, \vec{p}, t)$ of time $t$ , position $\vec{x}$, we look at a simulation box in 3 space dimensions and describe the distribution for a species as discrete macro particles in this box \cite{Burau2010}.
The movement of these macro particles are then described by their position and momentum, the acting force depend on their set mass $m$, charge $q$ and weighting $w$.
The weighting is determined by the exact density function which the macro particle represents and can also be seen as the number of real particles for each macro particle.


At last, the fields need to be divided into so called Yee-cells \cite{Yee1966}, which can be seen in \autoref{fig:cell}. The corresponding fields are placed between the grid points, motivated by the fact that the spatial derivatives of components lie between these components, 
at which place the time derivative is calculated (see \autoref{equ:derivE} and \autoref{equ:derivB}).

\begin{figure}
	\centering
	\missingfigure{}
	\caption{One Yee-cell. Note, that fields are calculated between the grid-points.}
	\label{fig:cell}
\end{figure}

When the macroparticles and the corresponding fields at each grid point $(i, \, j, \,k)$ at a timestep $n$ are given, the calculation of the next time step can start.
At first, the new fields are calculated at each grid point. Only the last two of Maxwell's equation need to be solved, which is done by numerical differentiation\todo{Explain the first two Maxwell equations}. 
An example for this calculation with the field components in $x$-direction can be found in \autoref{equ:derivE} and \autoref{equ:derivB}. Similar equations for the $y$-, and $z$-component can be found.

\begin{align}
	\frac{{E}_x\rvert_{i+1/2,\, j,\, k}^{n+1} - {E}_x\rvert_{i+1/2\, j,\, k}^{n}}{c^2\Delta t}
	=& \frac{{B}_z\rvert_{i+1/2,\, j+1/2,\, k}^{n+1/2} - {B}_z\rvert_{i+1/2\, j-1/2,\, k}^{n+1/2}}{\Delta y}
	- \frac{{B}_y\rvert_{i+1/2,\, j,\, k+1/2}^{n+1/2} - {B}_y\rvert_{i+1/2\, j,\, k-1/2}^{n+1/2}}{\Delta z}
	\label{equ:derivE}	\\&
	-\mu_0 J_x \rvert_{i+1/2,\, j,\, k}^{n+1/2}											\nonumber	\\
	 \frac{{B}_x\rvert_{i,\, j+1/2,\, k+1/2}^{n+3/2} - {B}_x\rvert_{i,\, j+1/2,\, k+1/2}^{n+1/2}}{\Delta t} 
	 =& \frac{{E}_y\rvert_{i,\, j+1/2,\, k+1}^{n+1} - {E}_y\rvert_{i\, j+1/2,\, k}^{n+1}}{\Delta z}
	- \frac{{E}_z\rvert_{i,\, j+1,\, k+1/2}^{n+1} - {E}_z\rvert_{i\, j,\, k+1/2}^{n+1}}{\Delta y}
	\label{equ:derivB}
\end{align} \todo{only second order spacial derivative, ArbitraryOrderFDTD<4> uses fourth order. Maybe append its solution in appendix}

First\todo{PIConGPU starts with field interpolation}, we calculate $\vec{E}^{(n+1)}$ from \autoref{equ:derivE}, then $\vec{B}^{(n+3/2)}$ from \autoref{equ:derivB}, giving us our fields at each grid point.
To get the forces acting on each macro particle, the grid fields need to be interpolated at their respective position. PIConGPU uses trilinear interpolation for this task \cite{Huebl2019, PICRepo}, a 3D extension of a normal linear interpolation.
Then the acting Lorentz Force can simply be calculated by \autoref{equ:lorentz}. With the forces at each particles position, now the particle pusher can calculate the new positions and momenta of the particle distributions.

There exist multiple implementations for this problem in PIConGPU, the standard one being the relativistic Boris-pusher \cite{Boris1970}, as it conserves the phase-space volume \cite{PICRepo}. Instead of centering the $\vec{B}$-field on integer timesteps, here the momentum at half integer timesteps is
calculated by only applying the first part of the Lorentz-Force $\vec{F}_L$ (the Coulomb-force) for $\Delta t/2$. Afterward the magnetic part of the Lorentz-Force is calculated at this half timestep $n+1/2$ and than added to the momentum, amounting for the full timestep.
At last, a Coulomb force is applied again for half a time step, so the momentum at the full step $n+1$ is returned \cite{Zenitani2018, Pausch2019}. Updating the particle position is just applying the Euler-method, see \autoref{equ:euler}.

\begin{equation}
	\vec{x}^{(n+1)} = \vec{x}^{(n)} + \Delta t \frac{\vec{p}^{(n+1)}}{\gamma m}
	\label{equ:euler}
\end{equation}

For the last step of the PIC-cycle, current $\vec{J}$ and charge density $\rho$ are calculated. \todo{write section about current deposition}

\subsection{Boundary Conditions}
The behavior of the fields and particles at the borders of the simulation box is determined by the boundary conditions.
For fields there exist two options in PIConGPU. Either the boundaries are periodic or absorbing. In the first case, when a field reaches the boundary, it wraps around the box and appears again at the other side on the same axis.
In the later case, the fields start to be absorbed at a set cell distance from the border, with the strength of the absorption increasing towards the boundary, until it fully vanishes at the border.
The \gls{pml}-absorber is used as the standard in PIConGPU, but the periodic behavior can be toggled for all individual directions (periodic behavior in longitudinal direction is normally not wanted).
Particles follow the periodicity of the fields, but have different option when no periodic conditions apply. For this thesis absorbing conditions are also used, so all particles crossing the border are deleted from the simulation.

\subsection{Acceleration pusher} \label{chap:accpush}
As will be later described in \autoref{chap:init}, the initial bunch from the \gls{lwfa} stage is only placed with given position and momentum of the macroparticles.
No corresponding fields are given, so these need to be created by the simulation. This is an iterative process where we first apply a constant force in longitudinal direction to our bunch and calculate backwards how it looked a given number of timesteps before \cite{Huebl2014}.
Then we can put it in the simulation, apply the same force and let it create a corresponding field through the PIC-cycle (see \autoref{	chap:pic}), while the bunch moves to it's initial position in phase space. 
Problem is, PIConGPU expects a charge free box, so when electrons are placed in the box it will automatically put a positive mirror charge behind every particle. This mirror charge would then pull back our real 
bunch, slowing it down in process. Therefore the acceleration pusher is used instead of the Boris pusher. Here, the constant accelerating force is the only acting force, completely ignoring the created fields.
The mirror charge therefor is left back, while the bunch moves outside its reach and the corresponding fields build up. When the bunch arrives at its initial position, the pusher can be changed to a physical pusher and
the real simulation can proceed.


\subsection{openPMD}
PIConGPU supports multiple plugins act as outputs for the simulated data. Most analysis in this thesis is done through the output of the openPMD-api \cite{openPMDAPI} plugin.
It returns the simulation data according to the openPMD standard, which provides a unified convention for naming and attributes of experimental data \cite{openPMDstandard}.
Stored will be data for the fields and the particle species for the timestep. Field data is stored per grid point and includes the $\vec{E}$- and $\vec{B}$-field as well as the charge- and energy density for every particle species.
For particles the position (cell + position in cell), momentum and weighting can be read for example. Additional non-standard attributes can be defined and stored, a use case of this will be described in \autoref{chap:param}.

\end{document}